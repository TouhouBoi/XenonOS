<?php
/*
  ___  _ __   ___ _   _  ___
 / _ \| '_ \ / _ \ | | |/ _ \
| (_) | | | |  __/ |_| |  __/
 \___/|_| |_|\___|\__, |\___|
                  |___/

oneye is released under the GNU Affero General Public License Version 3 (AGPL3)
 -> provided with this release in license.txt
 -> or via web at www.gnu.org/licenses/agpl-3.0.txt

Copyright Â© 2005 - 2010 eyeos Team (team@eyeos.org)
             since 2010 Lars Knickrehm (mail@lars-sh.de)
*/

function xenonUpload_on_advanced_Do($params = '') {
	global $myPid, $charBlackList;
	$file = basename($_FILES['Filedata']['name']);

	//We replace the forbidden characters by '-' to avoid failing the transfer just because of that
	$file = str_replace($charBlackList, '-', $file);

	$path = xenonFiles('cleanPath',array($GLOBALS['xenonUpload_Hidden_Path']->text));
	$path[0] .= '/' . $file;
	if (is_uploaded_file($_FILES['Filedata']['tmp_name'])) {
		if (!vfs('checkPermissions',array($path[0]))) {
			$response = array(
				'status' => array('failed'),
				'message' => array(i18n('translate',array('You do not have sufficient permissions!')))
			);
		} elseif (!vfs('checkQuota',array($_FILES['Filedata']['tmp_name']))) {
			$response = array(
				'status' => array('failed'),
				'message' => array(i18n('translate',array('You do not have enough free space!')))
			);
		} else {
			$countFiles = 0;
			$extension = substr(strrchr($path[0], '.'), 1); // utf8
			while ($path[1] != 'real' && vfs('fileExists',array($path[0])) || $path[1] == 'real' && vfs('real_fileExists',array($path[0]))) {
				$finalPathTemp = substr($path[0], 0, -strlen($extension) - 1); // utf8
				if ($countFiles) {
					$finalPathTemp = substr($path[0], 0, strlen($finalPathTemp) - strlen(strrchr($finalPathTemp, '_'))); // utf8
				}
				$countFiles++;
				$path[0] = $finalPathTemp . '_' . $countFiles . '.' . $extension;
			}
			if (@move_uploaded_file($_FILES['Filedata']['tmp_name'],$path[0]) && ($path[1] == 'real' || vfs('realToVirtual',array($path[0])))) {
				$_SESSION[$myPid]['advanced'] = 1;
				$response = array(
					'status' => array('success'),
					'message' => array(i18n('translate',array('"%s" has been uploaded successfully.',array(basename($path[0])))))
				);
			} else {
				$response = array(
					'status' => array('failed'),
					'message' => array(i18n('translate',array('Error occured during upload process!')))
				);
			}
		}
	} else {
		$response = array(
			'status' => array('failed'),
			'message' => array(i18n('translate',array('Error occured during upload process!')))
		);
	}
	echo xenonXML('array2xml',array(array('xenonUploadX' => array($response))));
	exit;
}

function xenonUpload_on_Close($params = '') {
	global $myPid;
	if (isset($_SESSION[$myPid]['advanced']) === true && $_SESSION[$myPid]['advanced'] === 1) {
		unset($_SESSION[$myPid]['advanced']);
		if ($GLOBALS['xenonUpload_Hidden_Callback']->text) {
			xenonx('rawjs',array('js' => $GLOBALS['xenonUpload_Hidden_Callback']->text));
		}
		xenonFiles('update',array($GLOBALS['xenonUpload_Hidden_Path']->text));
	}
	proc('end');
}

function xenonUpload_on_help($params=null) {
	proc('launch',array('xenonHelp','xenonUpload'));
}

function xenonUpload_on_initFlash($params = '') {
	$memory_limit = xenonFiles('stringToBytes', array(ini_get('memory_limit')));
	$post_max_size = xenonFiles('stringToBytes', array(ini_get('post_max_size')));
	$upload_max_filesize = xenonFiles('stringToBytes', array(ini_get('upload_max_filesize')));
	$maxUpload_bytes = min($memory_limit, $post_max_size, $upload_max_filesize);
	$maxUpload_mbytes = $maxUpload_bytes / (1024 * 1024);
	
	header('Content-type: text/xml');
	echo '
<xenonUploadX>
	<config>
		<upload_max_filesize>' . $maxUpload_bytes . '</upload_max_filesize>
	</config>
	<labels>
		<addFiles caption="' . utf8_htmlspecialchars(i18n('translate', array('Add files')), ENT_QUOTES) . '" />
		<maxUploadFilesize caption="' . utf8_htmlspecialchars(i18n('translate', array('Max filesize allowed')), ENT_QUOTES) . '" />
		<maxUploadFilesizeValue caption="' . utf8_htmlspecialchars(i18n('translate', array('%s MB', array($maxUpload_mbytes))), ENT_QUOTES) . '" />
		<progressFile caption="' . utf8_htmlspecialchars(i18n('translate', array('Transfering: ')), ENT_QUOTES) . '" />
		<progressInit caption="' . utf8_htmlspecialchars(i18n('translate', array('Add files to transfer, then press Upload now!')), ENT_QUOTES) . '" />
		<removeFile caption="' . utf8_htmlspecialchars(i18n('translate', array('Remove')), ENT_QUOTES) . '" />
		<upload caption="' . utf8_htmlspecialchars(i18n('translate', array('Upload now!')), ENT_QUOTES) . '" />
		<filenameColumnHeader caption="' . utf8_htmlspecialchars(i18n('translate', array('Filename')), ENT_QUOTES) . '" />
		<filesizeColumnHeader caption="' . utf8_htmlspecialchars(i18n('translate', array('Size (KB)')), ENT_QUOTES) . '" />
		<filesTooBigWarning caption="' . utf8_htmlspecialchars(i18n('translate', array('<b>Some files are too big!</b><br>Some of the selected files are too big and may be rejected by the server at the end of the transfer.<br>Do you want to remove them now?')), ENT_QUOTES) . '" />
		<questionYes caption="' . utf8_htmlspecialchars(i18n('translate', array('Yes')), ENT_QUOTES) . '" />
		<questionNo caption="' . utf8_htmlspecialchars(i18n('translate', array('No')), ENT_QUOTES) . '" />
		<messageOk caption="' . utf8_htmlspecialchars(i18n('translate', array('Ok')), ENT_QUOTES) . '" />
	</labels>
</xenonUploadX>';
	exit;
}

function xenonUpload_on_Message($params = '') {
	eyeWidgets('updateContent',$params);
}

function xenonUpload_on_simple_Do($params = '') {
	$path = xenonFiles('cleanPath',array($GLOBALS['xenonUpload_Hidden_Path']->text));
	if ($path[1] == 'real') {
		$suffix = 'real_';
	}
	if ($GLOBALS['xenonUpload_simple_File']->checkfile() && $GLOBALS['xenonUpload_simple_File']->saveFile($path[0],$suffix)) {
		$GLOBALS['xenonUpload_simple_File']->notify('simple_Done');
	} else {
		$GLOBALS['xenonUpload_simple_File']->notify('simple_Error');
	}
	exit;
}

function xenonUpload_on_simple_Done($params = '') {
	xenonx('messageBox',array('content' => 'The file has been uploaded successfully.'));
	xenonFiles('update',array($GLOBALS['xenonUpload_Hidden_Path']->text));
	proc('end');
}

function xenonUpload_on_simple_Error($params = '')  {
	xenonx('messageBox',array('content' => 'Error occured during upload process!'));
	proc('end');
}

function xenonUpload_on_web_Do($params = '') {
	$file = $GLOBALS['xenonUpload_web_Textbox']->text;
	$http = eyeURL('getHTTPClient');
	$http->setURL($file);
	$http->sendRequest();
	if ($http->getResponseBody()) {
		$path = xenonFiles('cleanPath',array($GLOBALS['xenonUpload_Hidden_Path']->text));
		$path[0] .= '/' . basename($file);
		$extension = substr(strrchr($path[0], '.'), 1); // utf8
		$countFiles = 0;
		while ($path[1] == 'real' && vfs('real_fileExists',array($path[0])) || $path[1] != 'real' && vfs('fileExists',array($path[0]))) {
			$pathTemp = substr($path[0], 0, -strlen($extension) - 1); // utf8
			if ($countFiles) {
				$pathTemp = substr($path[0], 0, strlen($pathTemp) - strlen(strrchr($pathTemp, '_'))); // utf8
			}
			$countFiles++;
			$path[0] = $pathTemp . '_' . $countFiles . '.' . $extension;
		}
		if ($path[1] == 'real') {
			vfs('real_create',array($path[0]));
			vfs('real_putFileContent',array($path[0],$http->getResponseBody()));
		} else {
			vfs('create',array($path[0]));
			vfs('writeFile',array($path[0],$http->getResponseBody()));
		}
		xenonx('messageBox',array('content' => 'File uploaded successfully.'));
		xenonFiles('update',array($GLOBALS['xenonUpload_Hidden_Path']->text));
		$GLOBALS['xenonUpload_web_Textbox']->setText('');
	} else {
		xenonx('messageBox',array('content' => 'Error uploading file!'));
	}
}
?>